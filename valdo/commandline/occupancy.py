"""
Use ligand-specific re-extrapolation to do occupancy estimation
https://github.com/Hekstra-Lab/drug-screening/issues/13
"""
import argparse, os, subprocess
import gemmi
import numpy as np 
import reciprocalspaceship as rs


class ArgumentParser(argparse.ArgumentParser):
    def __init__(self):
        super().__init__(
            formatter_class=argparse.RawTextHelpFormatter, description=__doc__
        )

        self.add_argument(
            "--pdbpath", 
            type=str, 
            help="Path to the pdb model with ligand refined"
        )

        self.add_argument(
            "--mtzpath", 
            type=str, 
            help="Path to the mtz data with scaled Fob and reconstructed magnitude"
        )

        self.add_argument(
            '--ext_factors', 
            nargs='+', 
            type=float,
            help="list of extrapolated factors"
        )

        self.add_argument(
            "--selection", 
            type=str, 
            help="seletion string sepcifying which atoms to minimize FOFC IADD, follow gemmi selection syntax"
        )

        self.add_argument(
            "--out_dir", 
            type=str, 
            help="Path to directory for the output and temp files"
        )

        self.add_argument(
            "--clean",
            action="store_true",
            help="Clean temporary files generated by phenix.maps in the process",
        )

        self.add_argument(
            "--Fob_col", 
            type=str,
            default="F-obs-scaled", 
            help="Column name of scaled Fob"
        )

        self.add_argument(
            "--recons_col", 
            type=str,
            default="recons", 
            help="Column name of reconstructed magnitude"
        )

        self.add_argument(
            "--roi_radius", 
            type=float,
            default=2.0, 
            help="ROI radius around target atoms"
        )


def mtz2grid(mtz_path, mag_column, ph_column):
    mtz_obj = gemmi.read_mtz_file(mtz_path)
    gridsize = mtz_obj.get_size_for_hkl(sample_rate=3.0)
    grid_obj = mtz_obj.transform_f_phi_to_map(mag_column, ph_column, exact_size=gridsize)
    grid_obj.normalize()
    return grid_obj


def get_map_around_selection(pdb_model, grid, selection, roi_radius=2):
    sele = gemmi.Selection(selection)
    sele_model = sele.copy_model_selection(pdb_model)
    mask_map = grid.clone()
    operations = grid.spacegroup.operations()
    mask_map.fill(0)
    for target in sele_model.all():
        eq_points = []
        # get all symmetry equivalent regions
        for op in operations:
            pos_oped = op.apply_to_xyz(mask_map.unit_cell.fractionalize(target.atom.pos).tolist())
            tmp = pos_oped-np.floor(np.array(pos_oped)) # Move into cell
            pos_oped = gemmi.Fractional(*tmp)
            eq_points.append(pos_oped)
        for pos in eq_points:
            mask_map.set_points_around(mask_map.unit_cell.orthogonalize(pos), radius=roi_radius, value=1)
    return np.array(mask_map) == 1


def main():
    args = ArgumentParser().parse_args()

    if os.path.isdir(args.out_dir):
        print("Output directory already exists!", flush=True)
    else:
        os.mkdir(args.out_dir)
        print("Output directory has been created!", flush=True)

    # Create extrapolated columns based on input factors
    ext_factors = np.round(args.ext_factors, 1)
    current_mtz = rs.read_mtz(args.mtzpath)
    for n in ext_factors:
        col_name = "ESF_"+f"{n:.1f}".replace(".", "p")
        current_mtz[col_name]=n*current_mtz[args.Fob_col] - (n-1)*current_mtz[args.recons_col]
        current_mtz[col_name]=current_mtz[col_name].astype("SFAmplitude")
    extrapolated_mtz_path = os.path.join(args.out_dir, "extrapolated.mtz")
    current_mtz.write_mtz(extrapolated_mtz_path)

    ligand_IDD = []
    mag_name = "mFo-DFc"
    ph_name = "PHmFo-DFc"
    pdb_model = gemmi.read_pdb(args.pdbpath)[0]
    for N in ext_factors:
        column_name = "ESF_"+f"{N:.1f}".replace(".", "p")
        command = [
            "phenix.maps",
            f"{args.pdbpath}",
            f"{extrapolated_mtz_path}",
            f"reflection_data.labels={column_name}",
            f"map_coefficients.map_type=mFo-DFc",
            f"output.directory={args.out_dir}",
            f"output.prefix={column_name}"
        ]
        temp_map_path = os.path.join(args.out_dir, f"{column_name}_map_coeffs.mtz")
        if os.path.exists(temp_map_path):
            print(f"{column_name}_map_coeffs.mtz already exists!", flush=True)
        else:
            subprocess.run(command)
        grid_obj = mtz2grid(temp_map_path, mag_name, ph_name)
        mask = get_map_around_selection(pdb_model, grid_obj, args.selection, roi_radius=args.roi_radius)
        ligand_IDD.append(np.mean(grid_obj.array[mask]))

    print("="*30 + " RESULTS " + "="*30, flush=True)
    print(f"{'Extrapolated-Factor':<18}  {'FO-FC_Mean_over_Targets':>25}", flush=True)
    for n, e in zip(ext_factors, ligand_IDD):
        print(f"{n:^18.1f} {e:^25.3f}", flush=True)

    opt_ext = ext_factors[np.argmin(np.abs(ligand_IDD))]
    print(f"Optimal  ExtFactor  : {opt_ext:.1f}", flush=True)
    print(f"Estimated Occupancy : {1/opt_ext:.3f}", flush=True)
    print(f"Optimal extrapolation saved in file: {extrapolated_mtz_path}", flush=True)
    print("Column: ", "ESF_"+f"{opt_ext:.1f}".replace(".", "p"), flush=True)

    if args.clean:
        for N in ext_factors:
            column_name = "ESF_"+f"{N:.1f}".replace(".", "p")
            temp_map_path = os.path.join(args.out_dir, f"{column_name}_map_coeffs.mtz")
            os.remove(temp_map_path)



    

    
    


    
